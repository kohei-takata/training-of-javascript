# SPECIFICATION

## データ型

データ型とはデータの種類です。文字列、数値、論理値など、様々な型があります。<br>
プログラミング言語には、このデータ型を強く制約するものと、ほとんど意識せず利用できるものがあります。<br>
JavaやGoなどは前者にあたり、PHPやJavaScriptは後者にあたります。<br>

例えば、文字列型で定義した変数に後から数値を入れることは前者、所謂静的型付け言語ではできません。対して後者の動的型付け言語では可能です。

```js
let x = 'string';
x = 10;
```

※FlowTypeやTypeScriptを利用することで静的型付け言語のような型チェックを行うことは可能です。

---

### JavaScriptの主なデータ型

JavaScriptのデータ型には基本型と参照型の二種類に分類できます。<br>
両者の違いは値を変数に格納する方法です。

#### 基本型

基本型は値そのものが直接格納されます。

|データ型|概要|
|:----|:----|
|数値型(Number)|IEEE 754 準拠の倍精度浮動小数点|
|文字列型(String)|シングル/ダブルクオートで囲まれた0個以上の文字の集合|
|真偽値(Boolean)|true or false|
|特殊型(null/undefined)|値が空、未定義|

---

#### 参照型

参照型は変数の参照値を格納します。（値を実際に格納しているメモリ上のアドレス）

|データ型|概要|
|:----|:----|
|配列(Array)|データの集合（各要素にはインデックス番号でアクセス）|
|オブジェクト(Object)|データの集合（各要素には名前でアクセス）|
|関数(Function)|一連の処理（手続き）の集合|

---

## リテラル
リテラルとはデータ型に格納できる値そのもの、もしくは値の表現方法をさします。

### 数値リテラル(Number)
数値リテラルはさらに整数リテラルと浮動小数点リテラルに分類できます。

- 整数リテラル
  - 10進数リテラル -> 0,1,100
  - 16進数リテラル -> 0xFFffFF, 0xCC55CC
  - 8進数リテラル(ES2015) -> 0o600
  - 2進数リテラル(ES2015) -> 0b11,0b101
- 浮動小数点リテラル -> 1.5, 3.14e5

浮動小数点リテラルは小数点と指数表現を使うことができます。<br>
このように数値リテラルにはさまざまな表現方法がありますがこれらは見かけ上の違いでしか無いのでどの表記をするかは自由です。
※0b10010(2進数), 0o22(8進数), 0x12(16進数), 1.8el(指数)はいずれも10進数の18

---

### 文字列リテラル
文字列リテラルはシングルクオート、ダブルクオートで囲む必要があります。
```js
'文字列リテラルです'
"文字列リテラルです"
```

しかし次の点で注意が必要です。
```js
'It's Failed'
```
文字列中にシングルクオートが存在するため文字列リテラルがそこで終了し、残りは解釈できない文字列になっててしまいます。この場合は以下の回避方法があります。
```js
"It's OK"
```
もしくは[エスケープシーケンス](https://msdn.microsoft.com/ja-jp/library/2yfce773(v=vs.94).aspx)を利用します。
```js
'It\'s OK'
```
このような回避方法はエスケープ処理と呼ばれます。

---

### テンプレート文字列(ES2015)
テンプレート文字列(Template literal)を利用することで以下のような文字列表現が可能です。

- 文字列への変数の埋め込み
- 改行を含む文字列

テンプレート文字列ではシングルクオート、ダブルクオートの代わりにバッククオートで文字列を囲います。

```js
let name = `pikachu`;
let msg = `いけ！${name}！
十万ボルトだ！`;
```

文字列リテラルで文字列中に変数を埋め込む場合は`+`を使って結合するしかありませんでしたが、テンプレート文字列であれば文字列中に埋め込むことができるようになったので可読性に優れています。

---

### 配列リテラル
配列とは、データの集合体です。<br>
ここまで扱った変数が１対１だったのに対し、配列は変数に１対複数の値を格納できるものです。<br>
値の一つ一つの値は要素と呼ばれます。<br>

配列リテラルは以下のようにカンマ区切りの値をブラケット`[]`でくくった形式で表現します。
```js
let pokemon = [
  'pikachu',
  'bulbasaur',
  'charmander',
  'squirtle',
];
```

---

|0|1|2|3|
|:----:|:----:|:----:|:----:|
|pikachu|bulbasaur|charmander|squirtle|

配列リテラルは、インデックス番号をキーとして要素にアクセスできます。
```js
console.log(pokemon[1]);
// bulbasaur
```

以下のように要素を入れ子に配列を持つこともできます。
```js
let pichu = [
  'pikachu', ['raichu']
];

console.log(pichu[0][0]); // raichu
```

---

### オブジェクトリテラル
オブジェクトは名前をキーとしてアクセスできる配列です。<br>
ハッシュ、連想配列などと呼ばれる場合もあります。<br>
通常の配列がインデックス番号しかキーにできないのに対し、オブジェクトでは文字列をキーにアクセスできるため、データの視認性（可読性）に優れます。

|name|age|gender|title|mothor|
|:----:|:----:|:----:|:----:|:----:|
|satoshi|10|man|pokemonMaster|hanako|

配列で個々の値を要素と呼んでいましたが、オブジェクトの場合はプロパティと呼びます。<br>
プロパティは文字列や数値の他に、関数を格納することも可能です。関数が格納されたプロパティはメソッドと呼びます。

---

オブジェクトリテラルは記法やアクセス方法が配列とは異なります。<br>
記法はブラケットではなく中括弧`{}`で囲みます。
```js
let hero = {
  'name': 'satoshi',
  'age': 10,
  'gender': 'man',
  'title': 'pokemonMaster',
  'mothor': 'hanako'
};
```

プロパティにアクセスする方法は２つあります。<br>
ドット演算子による方法とブラケット構文です。

```js
console.log(hero.name); // satoshi
console.log(hero['age']); // 10
```

---

しかし以下のパターンはアクセスできません。
```js
console.log(obj.123);
```

ドット演算子ではプロパティ名は識別子としてみなされるので識別子の命名規則に則していない数値などは使えません。ただし、ブラケット構文であればプロパティ名は文字列として指定するのでこのような制限はありません。

```js
console.log(obj['123']);
```

---

### 関数リテラル
関数とは処理のまとまりです。基本的には何かしらの入力値を与えて、なにかしらの処理をした結果を返すものですが、実装次第ではその限りではありません。<br>
関数に関してはここでは詳しく説明しません。

---

### 未定義値(undefined)
未定義値は変数に値が定義されていないことを表す値です。以下のケースで返されます。

- ある変数が宣言済みであるが値が与えられていないもの
- 未定義のプロパティを参照しようとした
- 関数で値が返されなかった

```js
let a;
console.log(a); // undefined
let obj = {x: 123};
console.log(obj.y); // undefined
```

---

### ヌル(null)
JavaScriptではもう一つ、該当する値がないことを意味する`null`という値も用意されています。<br>
`undefiend`が未設定、未定義、参照を想定されていない状態を表すのに対し、`null`は空である状態を表しています。<br>
例えばDOMへ存在しないID要素に参照しようとした場合、参照するためのメソッドは存在するがDOMは存在しなかった=空であった、という状態は`null`となります。

```js
document.getElementById('a'); // null
```

---

### [演算子](?md=/docs/03-SPECIFICATION-03)