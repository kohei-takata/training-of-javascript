# SPECIFICATION

## 演算子
演算子（オペレーター）とは与えられた変数・リテラルに対して、予め決められた何らかの処理を行うための記号です。<br>
また、演算子によって処理される変数・リテラルのことをオペランドと呼びます。

```js
x = a + b;
// = + はオペレーター
// x a b はオペランド
```

---

## 算術演算子
標準的な四則演算を始めとして、数学的な演算を行うのが算術演算子の役割です。代数演算子ともいいます。

#### 主な算術演算子

|演算子|概要|例|
|:----|:----|:----|
|+|数値の加算|3 + 5 // 8 |
|-|数値の減算|10 - 3 //3 |
|*|数値の乗算|3 * 5 // 15 |
|/|数値の除算|10 / 5 // 2 |
|%|数値の剰余|10 % 4 // 2 |
|++{var}|前置加算|x = 3; a = ++x; // a === 4 |
|{var}++|後置加算|x = 3; a = x++; // a === 3 |
|--{var}|前置減算|x = 3; a = --x; // a === 2 |
|{var}--|後置減算|x = 3; a = x--; // a === 3 |

---

### 加算演算子(+)の特徴
加算演算子(+)はオペランドのデータ型によって挙動が異なります。<br>
以下の例をみると、加算演算子はオペランドが数値リテラルのみの場合はそのまま数値を加算するが、文字列リテラルが含まれる場合は数値リテラルは文字列リテラルに暗黙の型変換が行われ、文字列連結演算子とみなされて文字結合を行います。その他オブジェクトリテラルの場合は暗黙的に文字列リテラルに変換されるためそのオブジェクトの`toString`関数が実行されて文字列連結が行われます。(オブジェクトによって異なるのでこの限りではありません。)

```js
10 + 1 // 11
'10' + 1 // '101'
123 + 'abc' // '123abc'
1234 + new Object() // '123[object Object]'
```

---

### インクリメント演算子(++)とデクリメント演算子(--)
インクリメント演算子はオペランドに対して1加算、デクリメント演算子はオペランドに対して1減算します。<br>
この演算子は先ほどの加算演算子とは反対に、数字を入れた文字列リテラルに対して行うと、暗黙的に数値リテラルに変換します。通常の文字列リテラルでは`NaN`というオブジェクトが返ります。

```js
let a = 1;
++a; // 2
let b = '1';
++b; // 2
let c = 'c';
++c; // NaN
```

---

### インクリメント・デクリメント演算子の落とし穴

この演算子を利用して他の変数に代入する際にはその挙動に注意が必要です。以下の例からその挙動を確認してみましょう。

```js
let x = 3;
let y = x++;
console.log(x); // 4
console.log(y); // 3
~~~
let x = 3;
let y = ++x;
console.log(x); // 4
console.log(y); // 4
```
この様に前後いずれかに置くことで代入された変数の結果が異なります。<br>
前方に置くことを前置演算、後方に置くことを後置演算と呼ばれます。<br>
この挙動の違いは、前置演算を変数に代入する場合は計算する前の状態が代入されるのに対し、後置演算は計算された状態が代入されるために結果が異なります。

---

### 小数点を含む計算の落とし穴

以下の例はJavaScriptが内部的には10進数ではなく、２進数で演算しているために以下のような結果が出力されます。
```js
console.log(0.2 * 3); // 0.6000000000000001
```

正しく計算する際は一度整数にすることが必要です。
```js
console.log(((0.2 * 10) * 3) / 10); // 0.6
```

---

## 代入演算子
指定された変数に値を代入するための演算子です。

### よく使う代入演算子

|演算子|概要|例|
|:----|:----|:----|
|=|変数などに値を代入|x = 1;|
|+=|加算したものを代入|x = 3; x += 2; // 5|
|-=|減算したものを代入|x = 3; x -= 2; // 1|
|*=|乗算したものを代入|x = 3; x *= 2; // 6|
|/=|除算したものを代入|x = 3; x /= 2; // 1.5|

---

## 基本型と参照型による代入の違い

基本型
```js
let x = 1;
let y = x;
x = 2;
console.log(y); // 1 
```

参照型
```js
let data1 = [0, 1, 2];
let data2 = data1;
data1[0] = 5;
console.log(data2); // [5, 1, 2]
```
基本型では値そのものがコピーされるのに対し、参照型ではメモリ上のアドレスを代入元のアドレスを共有するので代入元、代入先ともに変更が影響する。

---

## 分割代入
ES2015からは分割代入を行うことができます。<br>
分割代入とは配列・オブジェクトを分解し、配下の要素・プロパティ値を個々の変数に分解するための構文です。

### 配列
```js
const data [1, 2, 3, 4, 5];
const [a, b, c, d, e] = data;
console.log(b); // 2
```

### オブジェクト
```js
const hero = {
  'name': 'satoshi',
  'age': 10,
  'gender': 'man',
  'title': 'pokemonMaster',
  'mothor': 'hanako'
};
const { name, age, title } = hero;
console.log(title); // pokemonMaster
```

---

### 別名をつける
```js
const a = {a: 10, b:20, c:30};
const { a:b } = a;
console.log(b); // 10
```

### スプレッド演算子による代入(ES2018)
```js
const a = {a: 10, b:20, c:30};
const { a:b, ...c } = a;
console.log(c); // {b:20, c:30}
```
[proposal-object-rest-spread](https://github.com/tc39/proposal-object-rest-spread)

---

## 比較演算子
左辺・右辺の値を比較し、その結果を真偽値で返します。

### 主な比較演算子
|演算子|概要|例|
|:----|:----|:----|
|==|値が等しい場合はtrue|5 == 5 // true|
|!=|値が等しくない場合はtrue|5 != 5 // false|
|<|左辺が右辺より小さい場合はtrue|5 < 5 // false|
|<=|左辺が右辺以下の場合はtrue|5 <= 5 // true|
|>|左辺が右辺より大きい場合はtrue|5 > 3 // true|
|>=|左辺が右辺以上の場合はtrue|5 >= 3 // true|
|===|値とデータ型が同じ場合はtrue|5 === 5 // true|
|!==|値が異なる、データ型が異なる場合はtrue|5 !== 5 // false|
|?:|式がただし場合は:の左辺、正しくない場合は右辺|x = 1; (x === 1) ? 1 : 0 // 1|

---

## 等価演算子(==)
等価演算子ではデータ型の比較を行わずに、JavaScriptがよしなに等価ではないかと判定するものです。<br>
ですので、以下のようなケースが発生します。
```js
console.log(1 == true); // true
console.log('1' == 1); // true
```
しかし、参照型同士を比較した場合はお互いのメモリ上のアドレスが比較対象になります。
```js
const a = ['a', 'b', 'c'];
const b = ['a', 'b', 'c'];
console.log(a == b); //false
```
意図しない比較になりがちなので特に理由がない場合は同値演算子(===)を使用しましょう。

---

## 論理演算子
複数の条件式を結合し、その結果を真偽値で返します。

|演算子|概要|例|
|:----|:----|:----|
|&&|左右の式が共にtrueの場合はtrue|1 === 1 && 2 === 2 // true|
|││|左右の式のどちらかがtrueの場合はtrue|1 === 1 ││ 1 === 2 // true|
|!|式の真偽値を逆転させる|!(1 === 1) // false|

※マークダウンの関係上││は||

---

## ビット演算子
ビット演算子は実際にアプリケーションを作成する際に滅多に利用しない（当社比）のため説明しません。

---

## その他の演算子
ここまで紹介してきた演算子のカテゴリに分けられなかった演算子

|演算子|概要|
|:----|:----|
|,|左右の式を続けて実行|
|delete|オブジェクトのプロパティや配列の要素を削除|
|instanceof|オブジェクトが指定されたクラスのインスタンスかを判定|
|new|新しいインスタンスを生成|
|typeof|オペランドのデータ型を取得|
|void|未定義値を返す|

---

### [制御構文](?md=/docs/03-SPECIFICATION-04)
